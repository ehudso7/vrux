# VRUX Project Cursor Rules

You are an expert in TypeScript, React, Next.js, Tailwind CSS, and OpenAI API integration.

## Project Context
VRUX is an AI-powered UI component generator that creates production-ready React components from natural language descriptions. It uses GPT-4 for generation and React Live for real-time preview.

## Code Style and Structure
- Write concise, technical TypeScript/JavaScript code with accurate examples
- Use functional React components with hooks (no class components)
- Prefer named exports for components and utilities
- Use descriptive variable names (e.g., `isLoading`, `hasError`, `generateComponent`)
- Structure files: components in `/components`, utilities in `/lib`, API routes in `/pages/api`

## Tech Stack Preferences
- **UI**: Tailwind CSS for styling, avoid inline styles or CSS modules
- **Components**: Use the existing UI primitives in `/components/ui`
- **State Management**: React hooks (useState, useEffect) for local state
- **API Calls**: Use native fetch API with proper error handling
- **Preview**: React Live for component rendering

## Naming Conventions
- Components: PascalCase (e.g., `AIChatBox.jsx`)
- Utilities: camelCase (e.g., `rateLimiter.js`)
- API Routes: kebab-case (e.g., `generate-ui.js`)
- Constants: UPPER_SNAKE_CASE

## TypeScript/JavaScript Guidelines
- Use TypeScript for new utilities and shared types
- Use JavaScript for React components (following existing pattern)
- Define prop types using TypeScript interfaces when needed
- Avoid `any` type; use proper typing or `unknown`

## React Best Practices
- Keep components small and focused
- Extract reusable logic into custom hooks
- Use proper dependency arrays in useEffect
- Implement error boundaries for preview components
- Memoize expensive computations with useMemo

## AI Integration Guidelines
- Always validate and sanitize AI-generated code before rendering
- Implement proper error handling for API failures
- Include rate limiting for API endpoints
- Clean AI responses (remove markdown formatting)
- Provide clear system prompts for consistent output

## Error Handling
- Use try-catch blocks for async operations
- Provide user-friendly error messages
- Log errors appropriately (console in dev, service in prod)
- Implement fallback UI for error states

## Performance
- Use dynamic imports for heavy components (Preview)
- Implement proper loading states
- Optimize bundle size (check imports)
- Use Next.js Image component for images

## Security
- Never expose API keys to client
- Validate all user inputs
- Sanitize AI-generated code before execution
- Implement CORS properly
- Use environment variables for sensitive data

## Testing Approach
- Test API endpoints with various inputs
- Verify error handling works correctly
- Check responsive design on multiple devices
- Validate AI output parsing

## Documentation
- Comment complex logic and AI prompt engineering
- Keep README up to date with setup instructions
- Document API endpoints and their parameters
- Include examples of component generation

## When Adding Features
1. Check existing patterns in codebase
2. Reuse existing UI components
3. Follow established file structure
4. Update types if using TypeScript
5. Test with edge cases
6. Consider mobile responsiveness

## Common Commands
```bash
npm run dev      # Start development server
npm run build    # Build for production
npm run lint     # Run ESLint
npm start        # Start production server
```

## Git Commit Style
- Use conventional commits: feat:, fix:, docs:, style:, refactor:
- Keep commits atomic and focused
- Write clear commit messages

## PR Guidelines
- Test thoroughly before submitting
- Include description of changes
- Update documentation if needed
- Ensure all checks pass